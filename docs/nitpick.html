<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
	<title>Nitpick - Manual</title>
	<style type="text/css">
		.screenshot {
			width: 90%;
			margin-left: auto;
			margin-right: auto;
			border-width: 0.1em;
			border-style: solid;
		}

		.screenshot img {
			width: 100%;
		}
	</style>
</head>
<body>
	<h1>Table of Contents</h1>
	<ul>
		<li><a href="#quick_start">Quick Start</a></li>
		<li><a href="#what_is_nitpick">What is Nitpick?</a></li>
		<li><a href="#getting_nitpick">Getting Nitpick</a></li>
		<li><a href="#installation">Installation</a></li>
		<li><a href="#basic_usage">Basic Usage</a></li> <ul>
			<li><a href="#creating_a_repository">Creating a Repository</a></li>
			<li><a href="#starting_the_web_interface">Starting the Web Interface</a></li>
			<li><a href="#creating_issues">Creating Issues</a></li>
			<li><a href="#commenting">Commenting and Modifying Issues</a></li>
			<li><a href="#issue_source_control">Issue Source Control</a></li>
			<li><a href="#attachments">Attachments</a></li>
			<li><a href="#duplicate_issues">Duplicate Issues</a></li>
			<li><a href="#dependent_issues">Dependent Issues</a></li>
			<li><a href="#sorting_and_filtering">Sorting and Filtering</a></li>
		</ul>
		<li><a href="#advanced_usage">Advanced Usage</a></li> <ul>
			<li><a href="#configuring_nitpick">Configuring Nitpick</a></li> <ul>
				<li><a href="#configuring_users">Users</a></li>
				<li><a href="#configuring_issues">Issues</a></li>
			</ul>
			<li><a href="#foreign_projects">Foreign Projects</a></li> <ul>
				<li><a href="#configuring_foreign">Configuring</a></li>
				<li><a href="#between_branches">Between Branches</a></li>
				<li><a href="#across_projects">Across Projects</a></li>
			</ul>
		</ul>
	</ul>


	<a name="quick_start"></a><a href="#quick_start"><h1>Quick Start</h1></a>
		If you want to get started with Nitpick as quickly as possible these are the steps
		you have to follow:
		<ol>
			<li>Download Nitpick and place
			<a href="https://github.com/travisb-ca/nitpick/blob/master/nitpick.py">nitpick.py</a>
			into a directory in you path. You
			may wish to rename the file nitpick</li>

			<li>At the root of your project you must create a Nitpick repository. Run
			the command <tt>nitpick init --vcs <i>vcs</i></tt> where <i>vcs</i> is the
			VCS your project uses. Currently supported are: <tt>file</tt>, <tt>git</tt>,
			<tt>hg</tt> and <tt>svn</tt>.</li>

			<li>Start the Nitpick Web Interface by running the command <tt>nitpick
				web</tt> somewhere in the directory tree at or above your project
			root</li>

			<li>Create issues, comment on those issues and hit the <tt>Commit</tt>
			button to commit those changes into your local VCS.</li>
		</ol>

	<a name="what_is_nitpick"></a><a href="#what_is_nitpick"><h1>What is Nitpick?</h1></a>
		<p>
		Nitpick is a distributed issue tracker which keeps the issues alongside the code in
		the project verson control system. Similar to traditional centralized issue or bug
		trackers you can create issues, comment on issues, change various bits of metadata
		about issues and add attachments to issues. Unlike traditional issue trackers there
		is no central web server you have to access. Instead the issue database lives beside
		the source code inside the same version control system.
		</p>

		<p>
		Having the issue database beside the code provides several advantages over
		traditional issue trackers. The first of these is that no matter where the developer
		is they can view, modify and create issues. There is no central web server which
		requires Internet to access. For projects which use a DVCS like git or Mercurial,
		the advantages of having the issues beside the project are similar to the advantages
		of using those systems over a centralized VCS. These include disconnected operation
		and increased redundancy of the issue database, there is no central point of
		failure.
		</p>

		<p>
	 	One big feature of storing the issue database beside the code in a VCS is that when
		you branch the code you are also branching the issue database. If you create a
		branch to solve some particular issue then inside that branch you can create
		comments against that issue to document various decisions. Within that same branch
		you would mark the issue as closed and when that branch was merged back into the
		mainline the issue database there will automatically be updated with the new issue
		status.
		</p>

		<p>
		Conversely, if a new long lived branch is created then new issues can be created
		against only that branch. There is no guessing which branch an issue corresponds to
		because the current issue database always refers to the current branch. Nitpick also
		supports combining multiple Nitpick repositories across multiple branches to provide
		a complete view to the developer. For more about this advanced feature see <a
			href="#foreign_projects">Foreign Projects</a> below.
		</p>

	<a name="getting_nitpick"></a><a href="getting_nitpick"><h1>Getting Nitpick</h1></a>
		<p>
		You can get Nitpick in one of three ways. The first is to clone
		the git repository
		<tt>git clone https://github.com/travisb-ca/nitpick.git</tt>.
		The second is to download the latest release from this
		<a href="https://github.com/travisb-ca/nitpick/tarball/1.0.0-beta">link</a>.
		The third is to download the bleeding edge version of Nitpick
		<a href="https://github.com/travisb-ca/nitpick/blob/master/nitpick.py">directly</a>.
		</p>

	<a name="installation"></a><a href="#installation"><h1>Installation</h1></a>
		<p>
		Nitpick is a self contained system written in Python. All that it requires is a
		complete standard installation of Python 2.7. No additional Python libraries are
		required. Nitpick also requires the standard command line tools for your VCS.
		</p>

		<p>
		As a single file program installation is simply copying nitpick.py into a directory
		in your path and ensuring that the file is executable. An optional, but recommended,
		step is to rename the file nitpick, with no extension. All the commands in this
		manual will be written assuming you have named the Nitpick file "nitpick", but any
		name you desire will work.
		</p>
		
		<p>
		Once Nitpick has been copied into place you are ready to start using it. No
		additional configuration is necessary.
		</p>

	<a name="basic_usage"></a><a href="#basic_usage"><h1>Basic Usage</h1></a>

	<a name="creating_a_repository"></a><a href="#creating_a_repository"><h2>Creating a Repository</h2></a>
		<p>
		Unless you already have a project which has a Nitpick repository created for it you
		will have to create a new Nitpick repository. To do so you simply need to open a
		shell and go to the root of your project in source control. Once there you need only
		run the command <tt>nitpick init --vcs <i>vcs</i></tt>. This command will create a
		new Nitpick repository in the current directory under the hidden directory
		<tt>.nitpick</tt>. It will automatically initialize a default, empty repository and
		attempt to commit it to the VCS.
		</p>

		<p><i>vcs</i> must be chosen from the supported list of VCSes. Currently
		<tt>git</tt>, <tt>hg</tt>, <tt>svn</tt> and <tt>file</tt> are supported. The first
		three are well known VCSes. The <tt>file</tt> VCS is a null VCS which creates an
		unversioned Nitpick repository. This can be useful if you want to play around or try
		Nitpick with an unsupported VCS, though the <tt>file</tt> VCS doesn't support
		committing and reverting as the other VCS options do.
		</p>

		<p>
		If you use the Mercurial, <tt>hg</tt>, VCS option there is one additional step. In
		the project root you should see that the .hgignore file has been created/modified.
		You should review this file to ensure that it is acceptable. Nitpick has a few
		administrative files within its repository which must not be committed to the VCS
		and Nitpick will automatically add these files to the ignore list of the VCS. Since
		Mercurial requires modifying a user file it will not commit the ignore list
		automatically.
		</p>

	<a name="starting_the_web_interface"></a><a href="#starting_the_web_interface"><h2>Starting the Web Interface</h2></a>
		<p>
		Though there is a command line interface to Nitpick, it is not the preferred
		interface and exists primarily for scripts and power users. The preferred interface
		is the Web Interface. A static dump of the local web interface is available to be
		viewed <a href="http://travisbrown.ca/projects/nitpick/issues/index.html">on the web</a>.
		As this is a static dump certain features do not work, such as filtering or changing
		the fields shown in the index.
		</p>

		<p>
		The Web Interface uses an embedded web server to serve pages to your local browser
		in order to create a familiar interface. Nitpick will attempt to cause your local
		browser to open a new tab or window to the Nitpick Web Interface. If contacting a
		graphical browser fails it will attempt to find and start one of the standard
		terminal browsers instead. Failing that Nitpick will notify you of the address where
		you can view the Web Interface.
		</p>

		<p>
		Starting the Nitpick Web Interface is as easy as running the command <tt>nitpick
			web</tt> inside your project. Nitpick will automatically search the parent
		and grandparents, etc. of the current directory to search for a Nitpick repository.
		</p>

		<p>
		Starting the Web Interface on a repository will bring up the issue list, which will
		look something like:
		</p>
		<div class="screenshot"><img class="screenshot" src="images/empty_list.png"/></div>

		<p>
		This is the first page you see when starting the web interface and it is simply a
		list of sorting and filtering options, which are dealt with <a
			href="#sorting_and_filtering">later</a>, and the list of issues in the
		repository.
		</p>

	<a name="creating_issues"></a><a href="#creating_issues"><h2>Creating Issues</h2></a>
		<p>
		As you can see this is a new Nitpick repository and doesn't have any issues in it.
		We create an issue by clicking the "Create new issue" link near the top of the page.
		Clicking that link brings up the following page where we can fill in the fields for
		the new issue:
		</p>

		<div class="screenshot"><img class="screenshot" src="images/new_issue.png"/></div>

		<p>
		There are several fields which are required or available when creating an issue.
		Date is automatically filled in with the UTC date and time as of when you clicked
		the New Issue link. In Title you should enter a short, but informative title for the
		issue. Type is the type of the issue, the default value is chosen from the
		configuration value, but you can select from the configured options here. Similarly
		there is Component, Severity, Priority, Fix_By, State and Resolution. Resolution is
		usually kept on the default until the issue is solved.
		</p>

		<p>
		The Reported_By and Owner fields are a bit different. These fields are set to the
		username of the issue reporter and the current person the issue is assigned to
		respectively. The valid usernames must be configured in the Nitpick configuration
		and if Nitpick is able to determine your username from the configured list (by
		matching against your login name for example) then that suggestion will be
		selected by default. It is important to note that you cannot change the Reported_By
		field using the web interface after the issue has been created.
		</p>

		<p>
		Then we have three free form fields, Seen_In_Build, Depends_On and Duplicate_Of.
		Seen_In_Build is meant to contain a short description of when the problem was first
		seen, such as the first version of the software the issue occurs in. Depends_On and
		Duplicate_Of are usually left empty when creating a new issue, but are made
		available should you have that information at creation time.
		</p>

		<p>
		Finally there is a large textbox where the long form description of the issue can be
		put. We'll set the various metadata fields and comment as shown in this image and
		then submit the new issue.
		</p>

		<div class="screenshot"><img class="screenshot" src="images/new_issue_filled.png"/></div>

		<p>
		Submitting this issue will bring us to the following page:
		</p>

		<div class="screenshot"><img class="screenshot" src="images/submitted_issue.png"/></div>

		<p>
		From this page you can either go directly to the issue, or back to the issue list.
		The issue list will show something similar to:
		</p>

		<div class="screenshot"><img class="screenshot" src="images/one_issue_list.png"/></div>

		<p>
		We can easily see that we now have one issue. Going to this issue page is as easy as
		clicking on any link in the line for that issue. Doing so will bring us to the issue
		page:
		</p>

		<div class="screenshot"><img class="screenshot" src="images/issue_ca69.png"/></div>

	<a name="commenting"></a><a href="#commenting"><h2>Commenting and Modifying Issues</h2></a>
		<p>
		At the top of the issue page we see all the metadata about an issue. Most of it is
		the same from when creating the issue, but we also have the full issue identifying
		hash. This is useful for putting into the Depends_On or Duplicate_Of fields or in a
		comment when referring to the issue. To update the issue you should make the
		metadata modification you want and then click the "Update" button.
		</p>

		<p>
		Below the metadata are the issue description and comments. While you can't edit the
		issue description, you can add comments whenever necessary by clicking the "Add
		Comment" button. Doing so will open the new comment page, like so:
		</p>

		<div class="screenshot"><img class="screenshot" src="images/add_comment.png"/></div>

		<p>
		There are a few fields here which must be filled in. As with the Reported_By field
		previously mentioned the User field will suggest the current user if Nitpick can
		determine a match from the repository configuration. The two attachment fields will
		be left for <a href="#attachments">later</a>. That merely leaves the actual comment
		itself. Filling the comment in and submitting will bring us back to the page where
		we can choose to go back to the issue or to the list of issues. Going back to the
		issue we can see our comment is there:
		</p>

		<div class="screenshot"><img class="screenshot" src="images/issue_ca69_1_comment.png"/></div>

		<p>
		Nitpick supports threaded comments if you use the per-comment "Reply" comment. Doing
		so is recommended as it makes it easier to follow the discussion.
		</p>

		<div class="screenshot"><img class="screenshot" src="images/issue_ca69_x_comments.png"/></div>

		<p>
		Finally, putting an URL or issue hash in a comment will result in a link to that
		URL/issue.
		</p>

	<a name="issue_source_control"></a><a href="#issue_source_control"><h2>Issue Source Control</h2></a>
		<p>
		You may have noticed that after we created the issue some new buttons were created
		at the top of each page beside the "Exit Web Interface" button.
		</p>

		<div class="screenshot"><img class="screenshot" src="images/issue_ca69.png"/></div>

		<p>
		These new buttons, "Commit Changes" and "Revert Changes", are part of Nitpick's
		integration with your project VCS. Creating or modifying issues doesn't commit those
		changes to you VCS until you press the "Commit Changes" button. This let's you
		combine multiple Nitpick actions, such as commenting on multiple issues, into a
		single commit to you VCS, reducing clutter in your history. It also gives you the
		option to throw away any Nitpick changes you've made using the "Revert Changes"
		button.
		</p>

		<p>
		Those two buttons will restrict themselves to only the modified Nitpick data and
		will not touch other files which have been modified in your working copy or
		checkout. It is possible to commit changes to issues alongside the corresponding
		code by including the modified Nitpick files when doing a normal commit using your
		VCS. This is useful for keeping the code which fixes an issue and the marking of
		that issue as complete together.
		</p>

		<p>
		The VCS buttons only appear when using a real VCS (as opposed to the <tt>file</tt>
		VCS option when creating the repository) and Nitpick believes that you have made
		changes.
		</p>

	<a name="attachments"></a><a href="#attachments"><h2>Attachments</h2></a>
		<p>
		Nitpick supports including an attachment alongside any comment for an issue. This
		lets you keep important debugging or design information alongside the issue under
		discussion.
		</p>

		<div class="screenshot"><img class="screenshot" src="images/add_comment.png"/></div>

		<p>
		To add an attachment, when creating a comment simply select the file to attach and
		provide a descriptive filename to be shown for that attachment.
		</p>

		<div class="screenshot"><img class="screenshot" src="images/add_attachment.png"/></div>

		<p>
		Submitting this comment with attachment will result in a new attachment which has a
		link to the attachment.
		</p>

		<div class="screenshot"><img class="screenshot" src="images/issue_ca69_attachment.png"/></div>

	<a name="duplicate_issues"></a><a href="#duplicate_issues"><h2>Duplicate Issues</h2></a>
		<p>
		Marking an issue as a duplicate of another is useful when you have several issues
		reported and it is later determined that several issues are identical. In this case
		it can be useful to maintain this information in an easily navigable form. For this
		we have the Duplicate_Of field.
		</p>
		
		<p>
		This field is a space separated list of issue hashes which are a duplicate of this
		issue. Duplicate issue markings are commutative. That is, if issue A is marked as a
		duplicate of issue B and issue B is marked as a duplicate of issue C, issue A is
		also a duplicate of issue C. Currently a limited set of cases similar to this are
		traversed by Nitpick to produce the linked list of duplicate issues.
		</p>

		<p>
		To see this in action let us create two more issues
		</p>

		<div class="screenshot"><img class="screenshot" src="images/three_issue_list.png"/></div>

		<p>
		Obviously issue 8fc9253b is a duplicate of ca6968b0. If we go to the issue page for
		8fc9253b and enter a unique substring of the issue hash, like so:
		</p>

		<div class="screenshot"><img class="screenshot" src="images/make_duplicate.png"/></div>

		<p>
		When we update the issue with the "Update" button we'll see that the issue hash is
		completed and there is a new link to the issue the current issue is a duplicate of.
		</p>

		<div class="screenshot"><img class="screenshot" src="images/duplicate_issue.png"/></div>

		<p>
		Because this issue is a duplicate of the other issue we see that other issue's hash
		in the Duplicate_Of field. On the other issue we will see a link back to this issue,
		but not the full hash in the Duplicate_Of field because this issue hasn't been
		marked explicitly as a duplicate of the first issue.
		</p>

	<a name="dependent_issues"></a><a href="#dependent_issues"><h2>Dependent Issues</h2></a>
		<p>
		Recalling our list of issues, we will next see how to mark issues as dependent on
		one another and how this can be useful to track down what still needs to be done.
		</p>

		<div class="screenshot"><img class="screenshot" src="images/three_issue_list.png"/></div>

		<p>
		Looking at our issues we see that we have one to implement the Foo Mangler. You
		can't complete the documentation for the Foo Mangler until it is completed itself,
		so it would be useful to mark that issue as a dependency of the documentation
		effort. This is done similarly to marking an issue as a duplicate, but in the
		Depends_On field instead.
		</p>

		<div class="screenshot"><img class="screenshot" src="images/depends_on.png"/></div>

		<p>
		Updating the issue will then show a link to the issue the documentation depends
		upon.
		</p>

		<div class="screenshot"><img class="screenshot" src="images/depends_on_committed.png"/></div>

		<p>
		You'll note that the issue this issue depends on is now a link and further that it
		is a struck-through link. This is because that issue is 'Closed' (actually in the
		last configured state). If we go and look at that issue we will see that it has a
		dependent issue. Since dependency is a directional relationship it is only possible
		to add dependencies to the higher level issues.
		</p>

		<div class="screenshot"><img class="screenshot" src="images/dependent.png"/></div>

	<a name="sorting_and_filtering"></a><a href="#sorting_and_filtering"><h2>Sorting and Filtering</h2></a>
		<p>
		If we look back at the issue list we would see a number of filtering and display
		options at the top of the page as well as sorting options in the table header. These
		are useful to search through the issues to find one which matches your criteria. For
		example, if we wanted to find all the issues which are marked to be fixed for
		Release 1.0 which were created around a certain time we could setup the filtering as
		such:
		</p>

		<div class="screenshot"><img class="screenshot" src="images/filtering_setup.png"/></div>

		<p>
		Using the "Sort and Filter" button will submit these options and change the fields
		shown and only issues which are Bugs will be shown.
		</p>

		<div class="screenshot"><img class="screenshot" src="images/filtered.png"/></div>

		<p>
		This has filtered the issues, but that isn't sufficient. In order for us to find
		issues created around the correct time we need to sort on Date. We do that simply by
		clicking on the Date header in the table. There are three sort options for each
		column: neutral, ascending and descending. Only one column may be sorted on at a
		time. Let us click the Date header once to sort it ascending.
		</p>

		<div class="screenshot"><img class="screenshot" src="images/sorted.png"/></div>

		<p>
		With this sorting it would be easy for us to find the date range we are looking for.
		Clicking the header multiple times will cycle through the sorting choices. Saving a
		filter and sort pattern is as easy as getting the settings correct and then creating
		a bookmark using your browser.
		</p>

	<a name="advanced_usage"></a><a href="#advanced_usage"><h1>Advanced Usage</h1></a>
		<p>
		What has been described above are the basic necessities of Nitpick usage. Nitpick
		has a few more advanced features for those willing to do a bit of leg work.
		</p>

	<a name="configuring_nitpick"></a><a href="#configuring_nitpick"><h2>Configuring Nitpick</h2></a>
		<p>
		When a new Nitpick repository is created some reasonable defaults will be put in
		place. It is possible to modify these settings to fit the needs of the project
		better. As with all the issues and comments the configuration is made within the VCS
		and follows the repository wherever it should go.
		</p>

		<p>
		Most of the configuration knobs are lists of options for one field or another. When
		this is the case the first element of the configured list is the default selection.
		Nitpick makes no demands upon the lifecycle of an issue so option can, for the most
		part, be configured in any order and with any name.
		</p>

	<a name="configuring_users"></a><a href="#configuring_users"><h3>Users</h3></a>
		<p>
		The most useful configuration is to fill out the user list. This list is contained
		in the .nitpick/config/users file. The format is one user per line. The recommended
		format is at least an email address, though the actual format is freeform.
		</p>

		<p>
		One feature to keep in mind when filling this list in is that Nitpick will make an
		attempt to suggest a better default user from this file for the current user. It
		does this by finding the current user account as substring of one of the configured
		users. Therefore if my user account is <tt>travisb</tt> and the user list contains
		the value "<tt>Travis Brown (travisb)</tt>" and no other user which may make the
		match ambiguous then Nitpick will select this user by default for fields where the
		current user is appropriate. Such fields include the Reporter of new issues and the
		user when creating comments.
		</p>

		<p>
		If the Nitpick matching doesn't work due to ambiguous user matches or an account
		name which doesn't match the user list (this could happen if my account username was
		<tt>funnybunny</tt>, but it's my business email address which is in the user list)
		then you can set the <tt>NITPICK_USERNAME</tt> environment variable to use that
		user. Note that no matching into the user list will occur if you use this setting.
		</p>
	
	<a name="configuring_issues"></a><a href="#configuring_issues"><h3>Issues</h3></a>
		<p>
		For issues Nitpick has a number of selectable metadata states. These are for things
		like the issue component or target release, etc. These are all modifiable by
		modifying the .nitpick/config/config file. The format of each line is the list name,
		followed by a colon, followed by a space and then followed by a space separated list
		of options. The first option will be taken as the default when creating new issues.
		</p>

		<p>
		The <tt>state</tt> options are have a special case in that not only is the first
		option in the list the default when creating new issues, but the last one in the
		list is considered 'closed' by Nitpick. A closed issue will have any links to it
		shown as struck out to show that the issue is closed.
		</p>

		<p>
		With the above in mind it is recommended that the final <tt>state</tt> be Closed or
		some project equivalent. It is further recommended that the first <tt>fix_by</tt> be
		either the next release, or some triage release so new issues are kept at the
		forefront.
		</p>

	<a name="foreign_projects"></a><a href="#foreign_projects"><h2>Foreign Projects</h2></a>
		<p>
		As a distributed issue tracker a Nitpick repository is contained beside the source
		code in the project VCS. Though this model presents several advantages related to
		issue states and comments following the code through branches, it also presents
		difficulties in viewing issues across branches or between several projects spread
		across multiple VCS repositories.
		</p>

		<p>
		Nitpick solves this problem through Foreign Projects. A Foreign Project is another
		Nitpick repository, usually a root Nitpick repository of another project or branch,
		from which Nitpick will present a combined view of the issues and comments from all
		the projects. It is possible to change the state of or comment on issues in these
		Foreign Projects.
		</p>

		<p>
		When Foreign Projects are configured there is an additional possible filtering
		column, Project. The project of an issue will also be displayed on the issue page.
		</p>

	<a name="configuring_foreign"></a><a href="#configuring_foreign"><h3>Configuring</h3></a>
		<p>
		Configuring Foreign Projects is relatively simple. First you must create the
		directory <tt>.nitpick/foreign</tt>. Inside this directory you must create links of
		some sort to the foreign Nitpick repository. The name of the link will be the name
		of the project when viewed inside the Nitpick Web Interface.
		</p>

		<p>
		Any method of linking repositories which is functionally equivalent to a symlink or
		directory should work. Support for the version control functionality working inside
		Foreign projects varies with the capabilities of your VCS and Nitpick's support. For
		example, Subversion externals are fully supported where nested git repositories are
		not.
		</p>

	<a name="between_branches"></a><a href="#between_branches"><h3>Between Branches</h3></a>
		<p>
		One common use case for Foreign Projects is to combine issues and comments across
		the current branch with those found on the project trunk. Such a setup is especially
		useful between a release branch and the project trunk. In this situation the Foreign
		Project is a branch of the local Nitpick repository. Issues will be combined across
		them and it is possible to create issues in either the local repository or any of
		the foreign repositories. Comments will be created in an appropriate repository.
		</p>

		<p>
		If using Subversion externals to create the link you must watch out for infinite
		recursion when creating a link back to the current branch, such as if you wanted to
		create a Foreign project to the trunk in the trunk so all branches would
		automatically get the trunk as a Foreign project. The easiest way to avoid this is to setup the svn:external property on the root of your trunk/branch like so <tt>^/trunk/.nitpick .nitpick/foreign/Trunk</tt>. This example would create a Foreign Project to the trunk issue repository. When working on the trunk you won't see a Foreign Project field because all the issues are in the local repository. However, when you go to branch the trunk, the Foreign Project (trunk) will diverge and you will see the different project options.
		</p>

	<a name="across_projects"></a><a href="#across_projects"><h3>Across Projects</h3></a>
		<p>
		Configuring Foreign Projects across several different projects works quite similar
		to configuring across branches. The only major different is that Nitpick will
		combine all the configurations of the various repositories. That is, the set of all
		possible issue states from all repositories will be used when filtering or creating
		issues. It is recommended all projects have the same configuration. If this is not
		then case then it is up to the user to ensure that a valid component, state or other
		issue metadata is chosen for the particular project.
		</p>
</body>
</html>
